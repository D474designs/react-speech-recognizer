import React, { Component } from 'react'

const createSpeechRecognition = (lang, interimResults) => {
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition
  const recognition = new SpeechRecognition()
  recognition.lang = lang
  recognition.continuous = false
  recognition.interimResults = interimResults
  return recognition
}


const attachEvents = (recognition, {onEnd = ()=>{}, onError = ()=>{}, onStart = ()=>{}, onResult = ()=>{}}) => {
  recognition.onstart = onStart
  recognition.onend = onEnd
  recognition.onerror = onError
  recognition.onend = onEnd
  recognition.onresult = onResult
  return recognition
}

class SpeechRecognizer extends Component {
  componentDidMount() {
    this.initRecognition(this.props)
  }
  componentWillReceiveProps(nextProps) {
    this.initRecognition(nextProps)
  }
  componentWillUnmount() {
    this.recognition.abort()
  }
  initRecognition(props) {
    const { lang='en-GB', onNotAvailable , onTempResult, onResult, onStart, onError, onEnd } = this.props

    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
      return onNotAvailable && onNotAvailable()
    }

    // Abort previous instances of recognition already running
    if(this.recognition) this.recognition.abort()

    // Create new recognition
    const interimResult = !!onTempResult
    const recognition = attachEvents(createSpeechRecognition(lang, interimResult), {
      onStart: (e) => {
        console.log("onstart", e)
        onStart && onStart(e)
      },
      onEnd: (e) => {
        console.log("onend", e)
        this.initRecognition() // restart
        onEnd && onEnd(e)
      },
      onError: (error) => {
        console.log("onError", error)
        //this.initRecognition() // restart
        onError && onError(error)
      },
      onResult: (e) => {
        console.log("onresult", e)
        const transcript = e && e.results && e.results[0] && e.results[0][0]
          ?  e.results[0][0].transcript
          : null
        const isFinal = e && e.results && e.results[0]
          ? e.results[0].isFinal
          : null

        if(isFinal) {
          console.log("final")
          if(onResult) onResult(transcript)
          //this.initRecognition() // reset
        } else {
          console.log("temp")
          if(onTempResult) onTempResult(transcript)
        }
      }
    })

    // Start recognition
    recognition.start()

    // Store recognition so that it can be aborted
    this.recognition = recognition
  }

  render() {
    return null
  }
}

export default SpeechRecognizer
